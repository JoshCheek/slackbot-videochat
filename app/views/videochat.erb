<!DOCTYPE html>

<html lang="en">
  <head>
    <title>Slackbot Videochat</title>
  </head>

  <link href="/main.css?cache=false" rel="stylesheet">
  <div id="root"></div>

  <!-- pull it from public b/c it's broken on node w/ react -->
  <!-- https://github.com/twilio/twilio-video.js/issues/28  -->
  <script src="//media.twiliocdn.com/sdk/js/video/releases/1.0.0-beta2/twilio-video.js"></script>

  <script src="/main.js?cache=false"></script>

  <script>
  "use strict"

  // TODO: do those script tags execute asynchronously?
  // this code might need to be in an "on dom ready" thing

  // TODO: This needs to be escaped
  var roomName = "<%= @room_name %>"
  var token    = "<%= @token %>"
  var devmode  = ('dev' === roomName)

  if (!navigator.webkitGetUserMedia && !navigator.mozGetUserMedia)
    alert('WebRTC is not available in your browser.');
  else if (devmode)
    mockRoom(true).then(roomJoined)
  else
    new Twilio.Video.Client(token)
      .connect({to: roomName})
      .then(roomJoined, function(e) { alert(e.toString()) })

  function mockRoom(useTwilio) {
    var noop    = function() {}
    var me      = { identity: me, featured: false }
    var promise = null

    // Maybe it's a bug in Opera, but even when I swap out and don't use Twilio at all,
    // it shots my processor through the roof, even after I close the page :(
    if (useTwilio) {
      me.media = new Twilio.Video.LocalMedia()
      promise  = Twilio.Video.getUserMedia().then(function(stream) {
        me.media.addStream(stream)
        // me.media.pause() // For some reason, it's really taxing my processor, so pause it
      })
    } else {
      promise = navigator.mediaDevices.getUserMedia({video: true, audio: true}).then(function(stream) {
        me.media = {attach: function(parent) {
          var video = document.createElement("video")
          video.height = 100
          video.srcObject = stream
          parent.appendChild(video)
          video.onloadedmetadata = function(e) { /* video.play() */ }
        }}
      })
    }

    return promise.then(function() {
      return { participants: [], localParticipant: me, on: noop, disconnect: noop }
    })
  }


  function roomJoined(room) {
    var participants = []
    if (room.localParticipant)
      participants.push(room.localParticipant)
    room.participants.forEach(function(p) { participants.push(p) })

    // // comment this out to see it w/o react
    // // (in case that's what's setting the processor in a tizzy)
    // var parent = document.querySelector("div")
    // room.localParticipant.media.attach(parent)
    // return true

    // currently state is always "mediaList", but if we were to keep going with this
    // we would want it to be able to pass in things like erorr states
    var state = { type: "mediaList", list: participants }

    var dom = ReactDOM.render(
      React.createElement(App, { state: state, setFeatured: setFeatured }), // equivalent to <App state={state} setFeatured={setFeatured} />
      document.getElementById('root')
    )

    room.on('participantConnected', function(participant) {
      // add to participants and rerender
    })

    room.on('participantDisconnected', function (participant) {
      // instead, push this down into media,
      // remove it from our participants list here and then render again
      // participant.media.detach()
    });

    room.on('disconnected', function () {
      // ideally do something nice here, realistically this was supposed to be a 4 hr project
    })

    window.addEventListener('beforeunload', function() {
      // I thiiiiiink this is called when you leave the page, MDN docs don't tell you when unload is called,
      // but they give an example that involves leaving a page:
      // https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload
      //
      // Not sure why we need to disconnect, maybe to differentiate it from an interrupted connection
      // so that the other side dosn't think we might come back?
      room.disconnect()
    })

    function setFeatured(participant) {
      participants.forEach(p => p.featured = false)
      participant.featured = true
      dom.forceUpdate()
    }
  }
  </script>
</html>
