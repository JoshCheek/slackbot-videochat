<!DOCTYPE html>

<html lang="en">
  <head>
    <title>Slackbot Videochat</title>
  </head>

  <link href="/main.css?cache=false" rel="stylesheet">

  <div class="App">
    <div class="FeaturedPanel">
      <div class="Featured">
        <div class="Media" id="you"></div>
      </div>
    </div>
    <div class="Separator"></div>
    <div class="ListPanel">
      <div class="List">
        <div class="Media" id="me"></div>
      </div>
    </div>
  </div>

  <!-- pull it from public b/c it's broken on node w/ react -->
  <!-- https://github.com/twilio/twilio-video.js/issues/28  -->
  <script src="//media.twiliocdn.com/sdk/js/video/releases/1.0.0-beta2/twilio-video.js"></script>

  <script>
  "use strict"

  // TODO: do those script tags execute asynchronously?
  // this code might need to be in an "on dom ready" thing

  // TODO: This needs to be escaped
  var roomName = "<%= @room_name %>"
  var token    = "<%= @token %>"
  var devmode  = ('dev' === roomName)

  if (!navigator.webkitGetUserMedia && !navigator.mozGetUserMedia)
    alert('WebRTC is not available in your browser.');
  else if (devmode)
    mockRoom(true).then(roomJoined)
  else
    new Twilio.Video.Client(token)
      .connect({to: roomName})
      .then(roomJoined, function(e) { alert(e.toString()) })

  function mockRoom(useTwilio) {
    var noop    = function() {}
    var me      = { identity: 'me', featured: false }
    var promise = null

    // I think it's a bug in Opera, it sends the processor up to 130%
    // and they stay that way after I close the page :(
    // This happens even when I swap Twilio out and use the APIs directly
    if (useTwilio) {
      me.media = new Twilio.Video.LocalMedia()
      promise  = Twilio.Video.getUserMedia().then(function(stream) {
        me.media.addStream(stream)
      })
    } else {
      promise = navigator.mediaDevices.getUserMedia({video: true, audio: true}).then(function(stream) {
        me.media = {attach: function(parent) {
          var video = document.createElement("video")
          video.srcObject = stream
          parent.appendChild(video)
        }}
      })
    }

    return promise.then(function() {
      return { participants: [], localParticipant: me, on: noop, disconnect: noop }
    })
  }


  function roomJoined(room) {
    var me  = room.localParticipant
    var you = room.participants[0]

    me.media.attach(document.querySelector('#me'))
    if(you)
      you.media.attach(document.querySelector('#you'))

    room.on('participantConnected', function(participant) {
      console.log(`CONNECTED: ${participant.identity}`)
      you.media.attach(document.querySelector('#you'))
    })

    room.on('participantDisconnected', function (participant) {
      console.log(`DISCONNECTED: ${participant.identity}`)
      participants = participants.filter(function(p) { return p.identity !== participant.identity})
      if(featured.identity === participant.identity)
        featured = participants[participants.length-1]
      renderRoom()

      participant.media.detach() // push this down into media?
    });

    room.on('disconnected', function () {
      // ideally do something nice here, realistically this was supposed to be a 4 hr project
    })

    window.addEventListener('beforeunload', function() {
      // I thiiiiiink this is called when you leave the page, MDN docs don't tell you when unload is called,
      // but they give an example that involves leaving a page:
      // https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload
      //
      // Not sure why we need to disconnect, maybe to differentiate it from an interrupted connection
      // so that the other side dosn't think we might come back?
      room.disconnect()
    })
  }
  </script>
</html>
