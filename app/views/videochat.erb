<!DOCTYPE html>

<html lang="en">
  <head>
    <title>Slackbot Videochat</title>
  </head>

  <link href="/main.css?cache=false" rel="stylesheet">
  <div id="root"></div>

  <!-- pull it from public b/c it's broken on node w/ react -->
  <!-- https://github.com/twilio/twilio-video.js/issues/28  -->
  <script src="//media.twiliocdn.com/sdk/js/video/releases/1.0.0-beta2/twilio-video.js"></script>

  <script src="/main.js?cache=false"></script>

  <script>
  "use strict"

  // TODO: do those script tags execute asynchronously?
  // this code might need to be in an "on dom ready" thing

  // TODO: This needs to be escaped
  var roomName = "<%= @room_name %>"
  var token    = "<%= @token %>"
  var devmode  = ('dev' === roomName)

  if (!navigator.webkitGetUserMedia && !navigator.mozGetUserMedia)
    alert('WebRTC is not available in your browser.');
  else if (devmode)
    mockRoom(true).then(roomJoined)
  else
    new Twilio.Video.Client(token)
      .connect({to: roomName})
      .then(roomJoined, function(e) { alert(e.toString()) })

  function mockRoom(useTwilio) {
    var noop    = function() {}
    var me      = { identity: 'me', featured: false }
    var promise = null

    // I think it's a bug in Opera, it sends the processor up to 130%
    // and they stay that way after I close the page :(
    // This happens even when I swap Twilio out and use the APIs directly
    if (useTwilio) {
      me.media = new Twilio.Video.LocalMedia()
      promise  = Twilio.Video.getUserMedia().then(function(stream) {
        me.media.addStream(stream)
      })
    } else {
      promise = navigator.mediaDevices.getUserMedia({video: true, audio: true}).then(function(stream) {
        me.media = {attach: function(parent) {
          var video = document.createElement("video")
          video.srcObject = stream
          parent.appendChild(video)
        }}
      })
    }

    return promise.then(function() {
      return { participants: [], localParticipant: me, on: noop, disconnect: noop }
    })
  }


  function roomJoined(room) {
    var me           = room.localParticipant
    var participants = []
    if (me) participants.push(me)
    room.participants.forEach(function(p) { participants.push(p) })
    var featured = participants[participants.length-1]

    console.log(`Participants: ${participants.length}`)

    // currently state is always "mediaList", but if we were to keep going with this
    // we would want it to be able to pass in things like erorr states
    var renderRoom = function() {
      console.log(participants.map(p => p.identity))
      // equivalent to <App />
      ReactDOM.render(
        React.createElement(App, {
          list: participants,
          featured: featured,
          setFeatured: setFeatured
        }),
        document.getElementById('root')
      )
    }
    renderRoom()

    room.on('participantConnected', function(participant) {
      console.log(`CONNECTED: ${participant.identity}`)
      participants.push(participant)
      if(participants.length === 1)
        featured = participant
      renderRoom()
    })

    room.on('participantDisconnected', function (participant) {
      console.log(`DISCONNECTED: ${participant.identity}`)
      participants = participants.filter(function(p) { return p.identity !== participant.identity})
      if(featured.identity === participant.identity)
        featured = participants[participants.length-1]
      renderRoom()

      participant.media.detach() // push this down into media?
    });

    room.on('disconnected', function () {
      // ideally do something nice here, realistically this was supposed to be a 4 hr project
    })

    window.addEventListener('beforeunload', function() {
      // I thiiiiiink this is called when you leave the page, MDN docs don't tell you when unload is called,
      // but they give an example that involves leaving a page:
      // https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload
      //
      // Not sure why we need to disconnect, maybe to differentiate it from an interrupted connection
      // so that the other side dosn't think we might come back?
      room.disconnect()
    })

    function setFeatured(participant) {
      featured = participant
      renderRoom()
    }
  }
  </script>
</html>
